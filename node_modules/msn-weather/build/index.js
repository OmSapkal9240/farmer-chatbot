"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xml2js_1 = require("xml2js");
const validators_1 = require("./utils/validators");
const request_1 = __importDefault(require("./utils/request"));
const textIDs_1 = __importDefault(require("./utils/textIDs"));
function search(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options || typeof options !== "object") {
            throw new Error("Invalid options were specified");
        }
        if (!options.location) {
            throw new Error("No location was given");
        }
        const language = options.language || "en";
        const degreeType = options.degreeType || "C";
        if (!validators_1.isLanguageCode(language)) {
            throw new Error(`
            Invalid language code '${language}', make sure it adheres to the ISO 639.1:2002 standard
        `);
        }
        if (!validators_1.isDegreeType(degreeType)) {
            throw new Error(`Invalid degree type '${degreeType}'`);
        }
        const url = "https://weather.service.msn.com/find.aspx?src=msn&" +
            `weadegreetype=${degreeType}&` +
            `culture=${language}&` +
            `weasearchstr=${encodeURIComponent(options.location)}`;
        const response = yield request_1.default(url);
        const json = yield xml2js_1.parseStringPromise(response, {
            trim: true,
            mergeAttrs: true
        });
        if (!json || !json.weatherdata || !json.weatherdata.weather) {
            throw new Error("Couldn't parse response body");
        }
        const data = json.weatherdata.weather[0];
        if (!data.current) {
            throw new Error("Bad response: Failed to receive current weather data");
        }
        const current = data.current[0];
        for (const key in current) {
            current[key] = current[key][0];
        }
        if (!data.forecast) {
            throw new Error("Bad response: Failed to receive forecast weather data");
        }
        const forecasts = [];
        for (let i = 1; i < data.forecast.length; i++) {
            const forecast = data.forecast[i];
            forecasts.push({
                date: forecast.date[0],
                day: forecast.day[0],
                temperature: {
                    low: forecast.low[0] + `째${degreeType}`,
                    high: forecast.high[0] + `째${degreeType}`,
                },
                sky: {
                    code: textIDs_1.default[forecast.skycodeday[0]],
                    text: forecast.skytextday[0]
                },
                precip: forecast.precip[0] + "%"
            });
        }
        const weather = {
            current: {
                date: current.date,
                day: current.day,
                temperature: current.temperature + `째${degreeType}`,
                sky: {
                    code: textIDs_1.default[current.skycode],
                    text: current.skytext
                },
                observation: {
                    time: current.observationtime,
                    point: current.observationpoint
                },
                feelsLike: current.feelslike + `째${degreeType}`,
                humidity: current.humidity + "%",
                wind: {
                    display: current.winddisplay,
                    speed: current.windspeed
                }
            },
            forecasts
        };
        return weather;
    });
}
exports.default = {
    search
};
//# sourceMappingURL=index.js.map