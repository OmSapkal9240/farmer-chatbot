{
  "version": 3,
  "sources": ["../../fast-xml-parser/src/util.js", "../../fast-xml-parser/src/node2json.js", "../../fast-xml-parser/src/xmlNode.js", "../../strnum/strnum.js", "../../fast-xml-parser/src/xmlstr2xmlnode.js", "../../fast-xml-parser/src/validator.js", "../../fast-xml-parser/src/nimndata.js", "../../fast-xml-parser/src/node2json_str.js", "../../fast-xml-parser/src/json2xml.js", "../../fast-xml-parser/src/parser.js", "../../msn-weather/src/core/validators.ts", "browser-external:https", "../../msn-weather/src/core/request.ts", "../../msn-weather/src/core/textIDs.ts", "../../msn-weather/src/index.ts"],
  "sourcesContent": ["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  let newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n}\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n", "'use strict';\n\nconst util = require('./util');\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName)\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nexports.convertToJson = convertToJson;\n", "'use strict';\n\nmodule.exports = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n", "const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation\n        const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/); \n        // +00.123 => [ , '+', '00', '.123', ..\n        if(notation){\n            // console.log(notation)\n            if(options.leadingZeros){ //accept with leading zeros\n                trimmedStr = (notation[1] || \"\") + notation[3];\n            }else{\n                if(notation[2] === \"0\" && notation[3][0]=== \".\"){ //valid number\n                }else{\n                    return str;\n                }\n            }\n            return options.eNotation ? Number(trimmedStr) : str;\n        }else{\n            return str;\n        }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else if(options.leadingZeros && leadingZeros===str) return 0; //00\n            \n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str\n                }else  {\n                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}\n\nmodule.exports = toNumber;", "'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  numParseOptions: {\n    hex: true,\n    leadingZeros: true\n  },\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: [],\n  alwaysCreateTextNode: false\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'numParseOptions',\n  'stopNodes',\n  'alwaysCreateTextNode'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.numParseOptions);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.numParseOptions\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n", "'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n};\n\nconst props = ['allowBooleanAttributes'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n\n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n", "'use strict';\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //const itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n", "'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (let tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n", "'use strict';\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'rootNodeName', //when array as root\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  if(Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1){\n    jObj = {\n      [this.options.rootNodeName] : jObj\n    }\n  }\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            val += this.processTextOrObjNode(item, key, level)\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextNode(result.val, key, result.attrStr, level);\n  } else {\n    return this.buildObjNode(result.val, key, result.attrStr, level);\n  }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && val.indexOf('<') === -1) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor(val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n", "'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst validator = require('./validator');\n\nexports.parse = function(xmlData, givenOptions = {}, validationOption) {\n  if( validationOption){\n    if(validationOption === true) validationOption = {}\n    \n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error( result.err.msg)\n    }\n  }\n  if(givenOptions.parseTrueNumberOnly \n    && givenOptions.parseNodeValue !== false\n    && !givenOptions.numParseOptions){\n    \n      givenOptions.numParseOptions = {\n        leadingZeros: false,\n      }\n  }\n  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);\n\n  const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options)\n  //print(traversableObj, \"  \");\n  return nodeToJson.convertToJson(traversableObj, options);\n};\nexports.convertTonimn = require('./nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n\n\nfunction print(xmlNode, indentation){\n  if(xmlNode){\n    console.log(indentation + \"{\")\n    console.log(indentation + \"  \\\"tagName\\\": \\\"\" + xmlNode.tagname + \"\\\", \");\n    if(xmlNode.parent){\n      console.log(indentation + \"  \\\"parent\\\": \\\"\" + xmlNode.parent.tagname  + \"\\\", \");\n    }\n    console.log(indentation + \"  \\\"val\\\": \\\"\" + xmlNode.val  + \"\\\", \");\n    console.log(indentation + \"  \\\"attrs\\\": \" + JSON.stringify(xmlNode.attrsMap,null,4)  + \", \");\n\n    if(xmlNode.child){\n      console.log(indentation + \"\\\"child\\\": {\")\n      const indentation2 = indentation + indentation;\n      Object.keys(xmlNode.child).forEach( function(key) {\n        const node = xmlNode.child[key];\n\n        if(Array.isArray(node)){\n          console.log(indentation +  \"\\\"\"+key+\"\\\" :[\")\n          node.forEach( function(item,index) {\n            //console.log(indentation + \" \\\"\"+index+\"\\\" : [\")\n            print(item, indentation2);\n          })\n          console.log(indentation + \"],\")  \n        }else{\n          console.log(indentation + \" \\\"\"+key+\"\\\" : {\")\n          print(node, indentation2);\n          console.log(indentation + \"},\")  \n        }\n      });\n      console.log(indentation + \"},\")\n    }\n    console.log(indentation + \"},\")\n  }\n}\n", null, "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"https\" has been externalized for browser compatibility. Cannot access \"https.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", null, null, null],
  "mappings": "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",
  "names": []
}
